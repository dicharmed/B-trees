<html>
<head>
    <title>b_trees</title>
</head>
<body>
    <a name="b_trees"></a>
    <h2>Б-деревья</h2>
    <p><b>Дерево</b> — это иерархическая структура данных, состоящая из элементов(вершин, или узлов), которые связаны между собой отношениями типа «родительская вершина – дочерняя вершина».<br>
Номер максимального уровня дерева называется глубиной (или высотой) дерева. Если вершина не имеет потомков, то она называется терминальной вершиной, или листом. Нетерминальная вершина называется внутренней. Число непосредственных потомков внутренней вершины дерева называется степенью этой вершины. Максимальная степень всех вершин дерева называется степенью дерева. Дерево называется упорядоченным, если все непосредственные потомки любой вершины упорядочены. <br>
 В компьютерных программах деревья обычно описываются в виде динамических структур данных, каждый элемент которых является записью, содержащей информацию о некоторой вершине дерева и набор ссылок на непосредственных потомков данной вершины. Ссылки реализуются в виде указателей, а сами записи размещаются в динамической памяти. В объектно-ориентированных языках программирования со ссылочной объектной моделью вместо записей могут использоваться объекты, содержащие ссылки на другие объекты (в настоящем пособии такой способ представления деревьев не рассматривается). Для хранения информации о бинарном дереве достаточно использовать набор связанных записей, каждая из которых содержит поле Data (в котором хранится значение соответствующей вершины дерева) и два поля-указателя Left и Right (которые связывают данную вершину дерева с ее дочерними вершинами).<br>
<br>
<b>Бинарное дерево</b> — это иерархическая структура данных, в которой каждый узел имеет значение (оно же является в данном случае и ключом) и ссылки на левого и правого потомка. Узел, находящийся на самом верхнем уровне (не являющийся чьим либо потомком) называется корнем. Узлы, не имеющие потомков (оба потомка которых равны NULL) называются листьями.
Бинарное дерево поиска — это бинарное дерево, обладающее дополнительными свойствами: значение левого потомка меньше значения родителя, а значение правого потомка больше значения родителя для каждого узла дерева. То есть, данные в бинарном дереве поиска хранятся в отсортированном виде. При каждой операции вставки нового или удаления существующего узла отсортированный порядок дерева сохраняется. При поиске элемента сравнивается искомое значение с корнем. Если искомое больше корня, то поиск продолжается в правом потомке корня, если меньше, то в левом, если равно, то значение найдено и поиск прекращается.
<br>
<img src="btr.png" style="width: 300px;">
<br><br>
<b>Сбалансированное бинарное дерево поиска</b> — это бинарное дерево поиска с логарифмической высотой. Данное определение скорее идейное, чем строгое. Строгое определение оперирует разницей глубины самого глубокого и самого неглубокого листа (в AVL-деревьях) или отношением глубины самого глубокого и самого неглубокого листа (в красно-черных деревьях). В сбалансированном бинарном дереве поиска операции поиска, вставки и удаления выполняются за логарифмическое время (так как путь к любому листу от корня не более логарифма). В вырожденном случае несбалансированного бинарного дерева поиска, например, когда в пустое дерево вставлялась отсортированная последовательность, дерево превратится в линейный список, и операции поиска, вставки и удаления будут выполняться за линейное время. Поэтому балансировка дерева крайне важна. Технически балансировка осуществляется поворотами частей дерева при вставке нового элемента, если вставка данного элемента нарушила условие сбалансированности.
<br>
<img src="balancedTree.png" style="width: 400px;">
<br><br>
Сбалансированное бинарное дерево поиска применяется, когда необходимо осуществлять быстрый поиск элементов, чередующийся со вставками новых элементов и удалениями существующих. В случае, если набор элементов, хранящийся в структуре данных фиксирован и нет новых вставок и удалений, то массив предпочтительнее. Потому что поиск можно осуществлять алгоритмом бинарного поиска за то же логарифмическое время, но отсутствуют дополнительные издержки по хранению и использованию указателей. Например, в С++ ассоциативные контейнеры set и map представляют собой сбалансированное бинарное дерево поиска.
</p>
    
</body>
</html>