<html>
<head>
    <title>find_elem</title>
</head>
<body>
    <a name="find_elem"></a>
    <h2>Поиск элемента</h2>
    <p>Чтобы найти заданный элемент val, мы начинаем с корня и затем следуем вдоль ломаной линии уникального пути вниз до узла, содержащего val. В каждом узле n вдоль этого пути используем функцию сравнения для данного дерева на предмет сравнения val с элементом n->val, записанном в n. Если val меньше, чем n->val, то поиск продолжается, начиная с левого потомка узла n, если val больше, чем n->val, то поиск продолжается, начиная с правого потомка n, в противном случае возвращается значение n->val (и задача решена). Путь от корневого узла вниз до val называется путем поиска для val.<br>
<br>
Этот алгоритм поиска реализуется в компонентной функции find, которая возвращает обнаруженный ею указатель на элемент или NULL, если такой элемент не существует в дереве поиска.
<br>
<br>
template<class T> T SearchTree::find (T val)<br>
{<br>
  TreeNode *n = root;<br>
  while (n) {<br>
    int result = (*cmp) (val, n->val);<br>
    if (result < 0)<br>
      n = n->_lchild;<br>
	else if (result > 0)<br>
      n = n->_rchild;<br>
	else<br>
      return n->val;<br>
  }<br>
  return  NULL;<br>
}<br>
<br>
Этот алгоритм поиска можно сравнить с турниром, в котором участвуют некоторые кандидаты. В начале, когда мы начинаем с корня, в состав кандидатов входят все элементы в дереве поиска. В общем случае для каждого узла n в состав кандидатов входят все потомки n. На каждом этапе производится сравнение val с n->val. Если val меньше, чем n->val, то состав кандидатов сужается до элементов, находящихся в левом поддереве, а элементы в правом поддереве n, как и сам элемент n->val, исключаются из соревнования. Аналогичным образом, если val больше, чем n->val, то состав кандидатов сужается до правого поддерева n. Процесс продолжается до тех пор, пока не будет обнаружен элемент val или не останется ни одного кандидата, что означает, что элемент val не существует в дереве поиска.
<br>
Для нахождения наименьшего элемента мы начинаем с корня и прослеживаем связи с левым потомком до тех пор, пока не достигнем узла n, левый потомок которого пуст — это означает, что в узле n содержится наименьший элемент. Этот процесс также можно уподобить турниру. Для каждого узла n состав кандидатов определяется потомками узла n. На каждом шаге из состава кандидатов удаляются те элементы, которые больше или равны n->val и левый потомок n будет теперь выступать в качестве нового n. Процесс продолжается до тех пор, пока не будет достигнут некоторый узел n с пустым левым потомком и, полагая, что не осталось кандидатов меньше, чем n->val, и будет возвращено значение n->val.
<br>
Компонентная функция findMin возвращает наименьший элемент в данном дереве поиска, в ней происходит обращение к компонентной функции _findMin, которая реализует описанный ранее алгоритм поиска, начиная с узла n :
<br>
<br>
template<class T> T SearchTree<T>::findMin (void)<br>
{<br>
  TreeNode<T> *n = _findMin (root);<br>
  return (n ? n->val : NULL);<br>
}<br>
<br>
<br>
template<class T><br>
TreeNode<T> *SearchTree<T>::_findMin (TreeNode<T> *n)<br>
{<br>
  if (n  == NULL)<br>
    return NULL;<br>
  while   (n->_lchild)<br>
    n = n->_lchild;<br>
  return n;<br>
}<br>
<br>
Наибольший элемент в дереве поиска может быть найден аналогично, только отслеживаются связи с правым потомком вместо левого.
</p>
    
</body>
</html>